
CHIP Crossing {
    // Kieran Chun Kit Long 201978275
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];

    PARTS:
    DFF(in=NextPhase, out=Phase);
    
    //Directly using junction controller raw - no idea how to fix the bug I had, so I just messed with junc controller raw here
    Not(in=NextPhase, out=digitsZ);
    And(a=digitsZ, b=PowerOn, out=EnableZ);

    Or(a=NextPhase, b=false, out=digitsX);
    And(a=digitsX, b=PowerOn, out=EnableX);
    Not(in= PedMode, out= NotPed);
    //Lights get frozen here so that I can keep them the same state after PedMode ends
    And(a=EnableZ, b=NotPed, out=EnableZFrozen);
    And(a=EnableX, b=NotPed, out=EnableXFrozen);

    TrafficLight3(PowerOn=EnableZFrozen, X[0]=X0, X[1]=X1, X[2]=X2);
    TrafficLight3(PowerOn=EnableXFrozen, X[0]=Z0, X[1]=Z1, X[2]=Z2);
    
    //jc here specifies junction controller variables - just because i added it raw and to prevent confusion.
    //Detect XDone (X finishes its cycle when X = 100)
    Not(in=X1, out=nX1jc);
    Not(in=X0, out=nX0jc);
    And(a=nX1jc, b=nX0jc, out=X1X0Falsejc);
    And(a=X1X0Falsejc, b=X2, out=XDone);

    //detects whether the Z has finished its cycle
    Not(in=Z1, out=nZ1jc);
    Not(in=Z0, out=nZ0jc);
    And(a=nZ1jc, b=nZ0jc, out=Z1Z0Falsejc);
    And(a=Z1Z0Falsejc, b=Z2, out=ZDonejc);

    Not(in=Phase, out=nPhase);
    And(a=nPhase, b=XDone, out=XFlip);
    And(a=Phase, b=ZDonejc, out=ZFlip);
    Or(a=XFlip, b=ZFlip, out=CycleDone);
    Xor(a=Phase, b=CycleDone, out=NextPhase);

    //outputs the raw lights (HOPEFULLY IT WORKS)
    Or(a=X0, b=false, out=Xbase0);
    Or(a=X1, b=false, out=Xbase1);
    Or(a=X2, b=false, out=Xbase2);
    Or(a=Z0, b=false, out=Zbase0);
    Or(a=Z1, b=false, out=Zbase1);
    Or(a=Z2, b=false, out=Zbase2);

    //button latch (THIS SHOULD WORK!!! AFTER THE 5000TH ATTEMPT!!!!!
    Not(in=PedMode, out=AllowPress);
    And(a=Button, b=AllowPress, out=ButtonSetPulse);
    Or(a=ButtonSetPulse, b=PrevButtonPressed, out=ButtonSet);
    Not(in=StartPed, out=KeepLatch);
    And(a=ButtonSet, b=KeepLatch, out=ButtonLatchNext);
    DFF(in=ButtonLatchNext, out=PrevButtonPressed);
    Or(a=ButtonLatchNext, b=false, out=ButtonPressedTemp);
    Or(a= PedMode, b= StartPed, out= HoldButton);
    Mux(a= ButtonPressedTemp, b= true, sel= HoldButton, out= ButtonPressed);


    //zdone detection for crossing
    //detects whether the Z has finished its cycle
    Not(in=Zbase2, out=nZ2);
    Not(in=Zbase0, out=nZ0);
    And(a=nZ2, b=nZ0, out=Z2Z0False);
    And(a=Z2Z0False, b=Zbase1, out=ZDone);

    //resets Zdone when the pedmode activates for next cycle
    Mux(a=ZDone, b=false, sel=PedMode, out=ZDoneToDFF);
    DFF(in=ZDoneToDFF, out=PrevZDone);

    Not(in=PrevZDone, out=nPrevZDone);
    And(a=ZDone, b=nPrevZDone, out=ZDoneRising);

    //brute force lights to red (i dont have a way to simply make it only input and output red)
    Mux(a=Xbase0, b=false, sel=PedMode, out=Z[0]);
    Mux(a=Xbase1, b=false, sel=PedMode, out=Z[1]);
    Mux(a=Xbase2, b=true,  sel=PedMode, out=Z[2]);

    Mux(a=Zbase0, b=false, sel=PedMode, out=X[0]);
    Mux(a=Zbase1, b=false, sel=PedMode, out=X[1]);
    Mux(a=Zbase2, b=true,  sel=PedMode, out=X[2]);

    //activates PedMode if ZDone and the button has been pressed (and not already active)
    And(a=PrevButtonPressed, b=ZDoneRising, out=StartPedRaw);
    Not(in=PrevPedMode, out=NotPedModePrev);
    And(a=StartPedRaw, b=NotPedModePrev, out=StartPed);

    //delays the lights by one, which is a brute force fix to another bug I had
    DFF(in=StartPed, out=StartPedDelayed);

    //pedmode latch
    Or(a=StartPedDelayed, b=PrevPedMode, out=PedModeSet);
    Not(in=TimerDone, out=NotDone);
    And(a=PedModeSet, b=NotDone, out=PedMode);
    DFF(in=PedMode, out=PrevPedMode);

    //wait is true when pedmode is not active
    Not(in=PedMode, out=Wait);

    Or(a=StartPed, b=false, out=ResetSignal);

    Not(in=TimerDone, out=notTimerDone);
    And(a=PedMode, b=notTimerDone, out=DecSignal);

    DFF(in=DecSignal, out=DecSignalPrev);
    Or(a=DecSignal, b=DecSignalPrev, out=HasCounted);

    DisplayCounter(dec=DecSignal, reset=ResetSignal, a=c6, b=c5, c=c4, d=c3, e=c2, f=c1, g=c0, digits[0]=digits0, digits[1]=digits1, digits[2]=digits2, digits[3]=digits3);

    //show a null value when pedmode isnt on (to satisfy code)
    Mux(a=false, b=c0, sel=PedMode, out=C[0]);
    Mux(a=false, b=c1, sel=PedMode, out=C[1]);
    Mux(a=false, b=c2, sel=PedMode, out=C[2]);
    Mux(a=false, b=c3, sel=PedMode, out=C[3]);
    Mux(a=false, b=c4, sel=PedMode, out=C[4]);
    Mux(a=false, b=c5, sel=PedMode, out=C[5]);
    Mux(a=false, b=c6, sel=PedMode, out=C[6]);

    Or(a=digits0, b=false, out=t0);
    Or(a=digits1, b=false, out=t1);
    Or(a=digits2, b=false, out=t2);
    Or(a=digits3, b=false, out=t3);

    Not(in=t0, out=nt0);
    Not(in=t1, out=nt1);
    Not(in=t2, out=nt2);
    Not(in=t3, out=nt3);

    And(a=nt0, b=nt1, out=z01);
    And(a=nt2, b=nt3, out=z23);
    And(a=z01, b=z23, out=digitsIsZero);


    DFF(in=PedMode, out=PedModePrev2);
    Or(a=PedMode, b=PedModePrev2, out=HasStarted);

    Not(in=ResetSignal, out=NotReset);

    And(a=digitsIsZero, b=NotReset, out=ZeroAfterReset);
    And(a=ZeroAfterReset, b=HasStarted, out=ZeroAfterStart);
    And(a=ZeroAfterStart, b=HasCounted, out=TimerDoneRaw);

    DFF(in=TimerDoneRaw, out=TimerDone);
}