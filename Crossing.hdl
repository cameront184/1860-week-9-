CHIP Crossing {
    IN PowerOn, Button;
    OUT ButtonPressed, Wait, X[3], Z[3], C[7];

    PARTS:

    // Registers
    // traffic sequence state (0 to 7)
    Bit(in=sIn0, load=PowerOn, out=s0);
    Bit(in=sIn1, load=PowerOn, out=s1);
    Bit(in=sIn2, load=PowerOn, out=s2);

    // crossing active
    Bit(in=crossNext, load=PowerOn, out=cross);

    // button latched
    Bit(in=btnNext, load=PowerOn, out=btnLatched);

    // countdown (0 to 9)
    Or(a=PowerOn, b=false, out=loadCount);
    Bit(in=cIn0, load=loadCount, out=c0);
    Bit(in=cIn1, load=loadCount, out=c1);
    Bit(in=cIn2, load=loadCount, out=c2);
    Bit(in=cIn3, load=loadCount, out=c3);

    // detect when count=0 and state=7
    Or(a=c0, b=c1, out=cor01);
    Or(a=c2, b=c3, out=cor23);
    Or(a=cor01, b=cor23, out=countNotZero);
    Not(in=countNotZero, out=countIsZero);

    // state=7
    And(a=s0, b=s1, out=s01);
    And(a=s01, b=s2, out=state7);

    // crossing ends when cross = 1 and count = 0
    And(a=cross, b=countIsZero, out=crossEnd);
    Not(in=crossEnd, out=notCrossEnd);

    // Start the crossing only when we reach the end of the cycle (state 7) and a button has been latched
    And(a=btnLatched, b=state7, out=wantStart);
    And(a=wantStart, b=PowerOn, out=startCross);

    // crossing state register stays high until crossEnd
    Or(a=cross, b=startCross, out=crossOrStart);
    And(a=crossOrStart, b=notCrossEnd, out=crossNext);

    // Wait = 1 when not crossing and 0 during crossing
    Not(in=cross, out=Wait);

    Or(a=btnLatched, b=Button, out=btnOr);
    And(a=btnOr, b=notCrossEnd, out=btnNext);
    Or(a=btnLatched, b=false, out=ButtonPressed);

    // increment logic for state 0 to 7
    Not(in=s0, out=inc0);
    Xor(a=s0, b=s1, out=inc1);
    And(a=s0, b=s1, out=carry1);
    Xor(a=carry1, b=s2, out=inc2);

    // when PowerOn=1 load incremented value
    Mux(a=s0, b=inc0, sel=PowerOn, out=sn0);
    Mux(a=s1, b=inc1, sel=PowerOn, out=sn1);
    Mux(a=s2, b=inc2, sel=PowerOn, out=sn2);

    // override during crossing or at the moment we start crossing by force state to 0
    Or(a=cross, b=startCross, out=overrideState);
    Mux(a=sn0, b=false, sel=overrideState, out=sIn0);
    Mux(a=sn1, b=false, sel=overrideState, out=sIn1);
    Mux(a=sn2, b=false, sel=overrideState, out=sIn2);

    // Normal traffic lights (no crossing)
    Not(in=s0, out=ns0);
    Not(in=s1, out=ns1);
    Not(in=s2, out=ns2);

    // 4-step phase
    Or(a=ns1, b=false, out=phaseR);
    Or(a=s0,  b=false, out=phaseA);
    And(a=s1, b=ns0,  out=phaseG);

    // Base outputs before the crossing override
    Mux(a=true,   b=phaseR, sel=s2, out=XrBase);
    Mux(a=false,  b=phaseA, sel=s2, out=XaBase);
    Mux(a=false,  b=phaseG, sel=s2, out=XgBase);

    Mux(a=phaseR, b=true,   sel=s2, out=ZrBase);
    Mux(a=phaseA, b=false,  sel=s2, out=ZaBase);
    Mux(a=phaseG, b=false,  sel=s2, out=ZgBase);

    // Overrided outputs during crossing
    Mux(a=XrBase, b=true,  sel=cross, out=X[2]);
    Mux(a=XaBase, b=false, sel=cross, out=X[1]);
    Mux(a=XgBase, b=false, sel=cross, out=X[0]);

    Mux(a=ZrBase, b=true,  sel=cross, out=Z[2]);
    Mux(a=ZaBase, b=false, sel=cross, out=Z[1]);
    Mux(a=ZgBase, b=false, sel=cross, out=Z[0]);

    // Countdown from 9 then decrement while crossing
    And(a=cross, b=countNotZero, out=doDec);

    // subtracting 1
    Not(in=c0, out=dec0);

    Not(in=c0, out=bc1pre);
    And(a=doDec, b=bc1pre, out=borrow1);
    Xor(a=c1, b=borrow1, out=dec1);

    Not(in=c1, out=nc1);
    And(a=borrow1, b=nc1, out=borrow2);
    Xor(a=c2, b=borrow2, out=dec2);

    Not(in=c2, out=nc2);
    And(a=borrow2, b=nc2, out=borrow3);
    Xor(a=c3, b=borrow3, out=dec3);

    // load 9 = 1001 when starting crossing
    Mux(a=dec0, b=true,  sel=startCross, out=cIn0);
    Mux(a=dec1, b=false, sel=startCross, out=cIn1);
    Mux(a=dec2, b=false, sel=startCross, out=cIn2);
    Mux(a=dec3, b=true,  sel=startCross, out=cIn3);

    // 7-seg decoder for the crossing
    CrossingDecoder(in[0]=c0, in[1]=c1, in[2]=c2, in[3]=c3, out=segCcorr);

    // Only display during crossing
    Mux(a=false, b=segCcorr[0], sel=cross, out=C[0]);
    Mux(a=false, b=segCcorr[1], sel=cross, out=C[1]);
    Mux(a=false, b=segCcorr[2], sel=cross, out=C[2]);
    Mux(a=false, b=segCcorr[3], sel=cross, out=C[3]);
    Mux(a=false, b=segCcorr[4], sel=cross, out=C[4]);
    Mux(a=false, b=segCcorr[5], sel=cross, out=C[5]);
    Mux(a=false, b=segCcorr[6], sel=cross, out=C[6]);
}